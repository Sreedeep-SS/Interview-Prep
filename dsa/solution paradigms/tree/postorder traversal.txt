Given the root of a binary tree, return the postorder traversal of its nodes' values.

Recursive Approach:

class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        
        def dfs(node):
            if not node:
                return
            dfs(node.left)        # left
            dfs(node.right)       # right
            res.append(node.val)  # root
        
        dfs(root)
        return res

Iterative Approach 1 (Two Stacks)


    Push root to stack1

    Pop from stack1, push to stack2

    Push its children into stack1

    At the end, stack2 has root-right-left â†’ reverse = postorder


class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        stack1, stack2 = [root], []
        while stack1:
            node = stack1.pop()
            stack2.append(node.val)
            if node.left:
                stack1.append(node.left)
            if node.right:
                stack1.append(node.right)
        
        return stack2[::-1]


Iterative Approach 2 (One Stack, Tricky but Neat)

    We can simulate recursion with just one stack:

class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res, stack = [], []
        last_visited = None
        curr = root
        
        while curr or stack:
            if curr:
                stack.append(curr)
                curr = curr.left
            else:
                peek = stack[-1]
                if peek.right and last_visited != peek.right:
                    curr = peek.right
                else:
                    res.append(peek.val)
                    last_visited = stack.pop()
        
        return res
