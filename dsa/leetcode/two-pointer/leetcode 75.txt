LC 75. Sort Colors

Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library's sort function.


Example 1:
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

Example 2:
Input: nums = [2,0,1]
Output: [0,1,2]

Approaches:

1. Approach 1: Counting Sort (O(n), O(1) extra space)

    Count number of 0s, 1s, and 2s.

    Rewrite array with that many 0s, 1s, 2s.

    Simple, but not in-place in one pass.

2. Approach 2: Dutch National Flag Algorithm (Most Optimal — O(n), O(1))

    Invented by Edsger Dijkstra.
    We use 3 pointers:

        low → boundary for 0s

        mid → current element scanning

        high → boundary for 2s
    
Algorithm:

    Initialize low = 0, mid = 0, high = n-1.

    While mid <= high:

        If nums[mid] == 0: swap with nums[low], increment both low & mid.

        If nums[mid] == 1: just mid += 1.

        If nums[mid] == 2: swap with nums[high], decrement high.


Code:

    class Solution:
    def sortColors(self, nums: List[int]) -> None:
        low, mid, high = 0, 0, len(nums) - 1

        while mid <= high:
            if nums[mid] == 0:
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                mid += 1
            else:  # nums[mid] == 2
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1

Intuition (Why it works):

    low ensures everything before it is 0.

    mid scans the array.

    high ensures everything after it is 2.

    1s automatically end up in the middle.